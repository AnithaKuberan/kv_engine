#!/usr/bin/env python

import sys
import os
import glob
import subprocess

TARGET_VERSION=2

# Backported any to older versions of python
try:
    any
except NameError:
    def any(a):
        for i in a:
            if i:
                return True
        return False

def run_sql(sqlite, fn, sql, more_args=[]):
    args = ['-batch', '-bail']
    cmd = [sqlite] + args + more_args + [fn]
    p = subprocess.Popen(cmd,
                         stdin=subprocess.PIPE,
                         stdout=subprocess.PIPE,
                         stderr=subprocess.PIPE)
    (o,e) = p.communicate(sql)
    if p.returncode != 0:
        sys.stderr.write("Error running query:  %s\n" % sql)
        sys.stderr.write(e)
        sys.exit(1)
    return o

def version(sqlite, fn):
    return int(run_sql(sqlite, fn, "pragma user_version;").strip())

def findSqlite():
    cmd_dir = os.path.dirname(sys.argv[0])
    bin_dir = cmd_dir
    possible = [os.path.join(bin_dir, p) for p in ['sqlite3', 'sqlite3.exe']]
    sqlitebin = [p for p in possible if os.path.exists(p)][0]
    return sqlitebin

def copy_master(sqlite, src, dest):
    # Don't care too much about the data here, so we'll just let the
    # engine recreate it.  We do care about the user version, so we'll
    # fix that.
    run_sql(sqlite, dest, 'pragma user_version = %d;' % TARGET_VERSION)

class FieldMap(object):
    """Map fieldnames across versions."""

    def __init__(self, version):
        self._version = version

    @property
    def vb_version(self):
        return {0: '0'}.get(self._version, 'vb_version')

    @property
    def v(self):
        if self._version < 2:
            return "substr(v, 1, length(v) - 2)"
        else:
            return 'v'

    def __getattr__(self, x):
        return x

def convert(sqlite, version, src, dest):
    print 'Converting "%s" (v%d) -> "%s" (v%d)' % (src, version,
                                                   dest, TARGET_VERSION)
    q = """attach database "{dbpath}" as newdb;
create table if not exists newdb.kv
  (vbucket integer,
   vb_version integer,
   k varchar(250),
   flags integer,
   exptime integer,
   cas integer,
   v text);
insert into newdb.kv (vbucket, vb_version, k, flags, exptime, cas, v)
   select {f.vbucket}, {f.vb_version}, {f.k}, {f.flags},
          {f.exptime}, {f.cas}, {f.v} from kv;"""
    run_sql(sqlite, src, q.format(dbpath=dest, f=FieldMap(version)))

def usage(command, msg):
    e = """Error:  %s

Usage:  %s /path/to/srcdb [...] /path/to/dest

src is the path to the main database.  You can specify more than one.
dest can be either a new main database filename, or a directory
(the old DB name will be used).

If more than one src db is specified, the destination *must* be a
directory.""" % (msg, command)
    sys.exit(e)

def doset(sqlite, src, dest):
    v = version(sqlite, src)
    print 'Source version from "%s" is %d' % (src, v)

    oldbase = os.path.basename(src)
    if os.path.isdir(dest):
        dest = os.path.join(dest, oldbase)

    copy_master(sqlite, src, dest)
    destdir = os.path.dirname(dest)
    destbase = os.path.basename(dest)
    for d in glob.glob(src + '*.mb') + glob.glob(src + '*.sqlite'):
        bn = os.path.basename(d)
        if bn.endswith('.sqlite'):
            bn = bn.replace('.sqlite', '.mb')
        destfile = bn.replace(oldbase, destbase)
        convert(sqlite, v, d, os.path.join(destdir, destfile))

def main():
    command = sys.argv[0]
    args = sys.argv[1:]
    try:
        dest = args.pop()
        srcs = args
        if not srcs:
            usage(command, "No destination specified")
        if any(os.path.isdir(p) for p in srcs):
            usage(command, "Source must point to main DBs, not directories")
        if len(srcs) > 1 and not os.path.isdir(dest):
            usage(command,
                  "Multiple sources, but destination is not a directory.")
    except IndexError:
        usage(command, "Too few arguments")

    sqlite = findSqlite()

    for src in srcs:
        doset(sqlite, src, dest)

if __name__ == '__main__':
    main()
