
# Collections

This document contains some brief diagrams to help aid the understanding of
important state changes within the collection's code and the impact those
state changes have on persistence and DCP.

## Collection state change diagram

The following diagram shows a collections lifetime when stimuli occurs. The
stimuli are new JSON Collections::Manifests being applied to the
Collections::VB::Manifest.  For example a new manifest with a previously unknown
collection triggers entry into the state diagram, a manifest that now omits a
known collection would move the known collection to exclusive deleting.


Collections state changes:
```
        ●
        │┌────────────────────────┐
        ├┤ Collection is created  │
        │└────────────────────────┘
        ▼
   .─────────.
  /           \
 :  exclusive  : ◀──────────────────────────────┐
 :    open     :                                │
  \           /                                 │
    ─────────                                   │
        │                                       │┌─────────────────────────┐
        │                                       ├┤Collection (old revision)│
        │                                       ││  is completely deleted  │
        │┌────────────────────────┐             ││   (all items removed)   │
        ├┤ Collection is deleted  │             │└─────────────────────────┘
        │└────────────────────────┘             │
        ▼                                       │
  .─────────.                                  .─────────.
 /           \                                /           \
:  exclusive  : ────────────┬──────────────▶ :  open and   :
:  deleting   : ┌───────────┴─────────────┐  :  deleting   :
 \           /  │ Collection of same name │   \           /
   ─────────    │(new revision) is created│     ─────────
        │       └─────────────────────────┘
        │
        │┌───────────────────────────┐
        ├┤ Collection is completely  │
        ││deleted (all items removed)│
        │└───────────────────────────┘
        ●
```

## State diagram with SystemEvents

The same state diagram is now annotated to show the SystemEvents that are
generated by each state change.

A SystemEvent is a 'special' Item owned by the server, but queued into the
user's data stream. The SystemEvent allows the flusher and DCP to trigger
specific actions that will be ordered with the user's data stream.

A SystemEvent can be created and for some use-cases, deleted. For collections
the end of a collection is denoted by a deleted Collection event.

```
                          ●
                          │
 ┌───────────────────────┐│
 │      Collection       ├┤
 └───────────────────────┘▼
                     .─────────.
                    /           \
                   :  exclusive  : ◀──────────────────────────────┐
                   :    open     :                                │
                    \           /                                 │
                      ─────────                                   │
                          │                                       │
                          │                                       │
                          │                                       │
                          │                                       │
┌────────────────────────┐│                                       │┌─────────────────────────┐
│  Collection [deleted]  ├┤                                       ├┤  DeleteCollectionSoft   │
└────────────────────────┘▼          ┌───────────────────────┐    │└─────────────────────────┘
                    .─────────.      │       Collection      │   .─────────.
                   /           \     └───────────┬───────────┘  /           \
                  :  exclusive  : ───────────────┴───────────▶ :  open and   :
                  :  deleting   :                              :  deleting   :
                   \           /                                \           /
                     ─────────                                    ─────────
                          │
                          │┌────────────────────────┐
                          ├┤  DeleteCollectionHard  │
                          │└────────────────────────┘
                          │
                          │
                          ●
```

## Collection States and Sequence Numbers

A collection's state is determined by the sequence numbers assigned to the
collection.

For example, when a collection is created we record the sequence number at which
we queue the create SystemEvent. And when a collection is deleted we record the
sequence number at which we queue the delete SystemEvent. This gives us a
sequence number life-time of a collection.

* Each collection has a `start_seqno` and an `end_seqno`.
* The `end_seqno` is permitted to have a special value of -6, this value means there is no end.

### Determining states from the seqno start/end:
* Exclusive Open
  * `end_seqno < start_seqno`
* Exclusive Deleting
  * `end_seqno > start_seqno`
* Open and Deleting
  * `end_seqno > 0 && end_seqno < start_seqno`

## VBucket JSON manifest

The code refers to a serialised JSON VB manifest. This is a persisted copy of
the VB::Manifest which can be used to recover a VBucket's collection state
following a restart.

The VB::Manifest is also recording the sequence number of the system-events and
uses those values to track a collection's life time. A VBucket JSON manifest
looks like the following (although we don't store a white space formatted
document).

```
{
   "collections":[
      {"name":"$default","uid":"0","start_seqno":"1","end_seqno":"-6"},
      {"name":"fruit","uid":"1","start_seqno":"13012","end_seqno":"-6"},
    ]
}
```

## SystemEvents

The SystemEvents are represented by the Item object. We weave SystemEvents into
the Checkpoint allowing DCP and the Flusher to see the event and then respond to
it, or ignore it. A SystemEvent Item can also be marked as deleted which
collections utilises for marking the logical delete of a collection.

A SystemEvent is a special case of Item and is identified primarily by the
operation member being set to "queue_op::system_event". The type of the
SystemEvent is stored in the flags field as an int.

### SystemEvent Identification

Consider the 'fruit' collection.

* Creating a fruit collection generates the following Item.
  * event = `SystemEvent::Collection`, key = `$collection::fruit`, deleted = false
  * The value must at least store the UID of the collection.
* Logically deleting the fruit collection generates the following Item.
  * event = `SystemEvent::Collection`, key = `$collection::fruit`, deleted = true
* If all data of a collection is deleted but the collection has been added back (with a new UID)
  * event = `SystemEvent::DeleteCollectionSoft`, key = `$collection::fruit`, deleted = false
* If all data of a collection is deleted
  * event = `SystemEvent::DeleteCollectionHard`, key = `$collection::fruit`, deleted = false

### SystemEvent flushing actions

SystemEvents are treated differently by the flusher.

* `Collection`
  * Sets or Deletes a document called `$collection::fruit` with a value that at least contains the UID
  * Updates the `_local/collections_manifest` (A JSON copy of the VB::Manifest)
* `DeleteCollectionSoft`
  * Updates the `_local/collections_manifest` (A JSON copy of the VB::Manifest) so that the collection remains but now with no endSeqno
* `DeleteCollectionHard`
  * Updates the `_local/collections_manifest` (A JSON copy of the VB::Manifest) so that the collection metadata is all gone

### SystemEvent DCP actions

SystemEvents are treated differently by the ActiveStream.

* `Collection`
  * `!isDeleted` Sends DcpSystem event message containing mcbp::CreateCollection, `key="fruit"` and `value="$UID"` (the value of UID)
  * `isDeleted` Sends DcpSystem event message containing mcbp::DeleteCollection, `key="fruit"` and `value="$UID"` (the value of UID)
* `DeleteCollectionSoft`
  * Ignored by DCP
* `DeleteCollectionHard`
  * Ignored by DCP

## Examples

### create/delete

1. Start with `$default=exclusive open`
2. Receive (assume VB high-seqno is 200)

   `{"collections":[{"name":"$default", "uid":"0"}, {"name":"fruit","uid":"1"}]}`

  * `$default=exclusive open, fruit=exclusive open`
  * stores a document `$collection::fruit` at seqno 201 with a value at least containing 1.
  * _local/collections_manifest
   ```
  {"collections":[
      {"name":"$default","uid":"0","start_seqno":"1","end_seqno":"-6"},
      {"name":"fruit","uid":"1","start_seqno":"201","end_seqno":"-6"}]}
   ```
3. Receive (assume VB high-seqno is now 430)

   `{"collections":[{"name":"$default", "uid":"0"}]}`

  * `$default=exclusive open, fruit=exclusive deleting`
  * note the creation of a deleted(SystemEvent::Collection) will trigger a background scrub of the collection's items.
  * _local/collections_manifest
   ```
  {"collections":[
      {"name":"$default","uid":"0","start_seqno":"1","end_seqno":"-6"},
      {"name":"fruit","uid":"1","start_seqno":"201","end_seqno":"431"}]}
   ```

4. When the background delete of fruit is complete and assuming VB high-seqno is now 561

  * `$default=exclusive open`
  * _local/collections_manifest (now fruit is deleted 'hard')
   ```
  {"collections":[
      {"name":"$default","uid":"0","start_seqno":"1","end_seqno":"-6"}]}
   ```

### create/delete/create

1. Start with `$default=exclusive open`
2. Receive (assume VB high-seqno is 836)

   `{"collections":[{"name":"$default", "uid":"0"}, {"name":"fruit","uid":"1"}]}`

  * `$default=exclusive open, fruit=exclusive open`
  * stored a document `$collection::fruit` at seqno 837
  * _local/collections_manifest
   ```
  {"collections":[
      {"name":"$default","uid":"0","start_seqno":"1","end_seqno":"-6"},
      {"name":"fruit","uid":"1","start_seqno":"837","end_seqno":"-6"}]}
   ```
3. Receive (assume VB high-seqno = 919)

   `{"collections":[{"name":"$default", "uid":"0"}]}`

  * `$default=exclusive open, fruit=exclusive deleting`
  * note the creation of a deleted(SystemEvent::Collection) will trigger a background scrub of the collection's items.
  * _local/collections_manifest
   ```
  {"collections":[
      {"name":"$default","uid":"0","start_seqno":"1","end_seqno":"-6"},
      {"name":"fruit","uid":"1","start_seqno":"837","end_seqno":"920"}]}
   ```
4. Receive (before the background delete completes, VB high-seqno = 1617)

   `{"collections":[{"name":"$default", "uid":"0"}, {"name":"fruit","uid":"2"}]}`

  * `$default=exclusive open, fruit=open and deleting`
  * store a document `$collection::fruit` at seqno 1618 with value at least containing the UID of 2
  * _local/collections_manifest
   ```
  {"collections":[
      {"name":"$default","uid":"0","start_seqno":"1","end_seqno":"-6"},
      {"name":"fruit","uid":"3","start_seqno":"1618","end_seqno":"920"}]}
   ```
5. When the background delete of fruit is complete and assuming VB high-seqno = 2010

  * `$default=exclusive open, fruit=exclusive open`
  * _local/collections_manifest (now fruit is deleted 'soft')
   ```
  {"collections":[
      {"name":"$default","uid":"0","start_seqno":"1","end_seqno":"-6"},
      {"name":"fruit","uid":"3","start_seqno":"1618","end_seqno":"-6"}]}
   ```
